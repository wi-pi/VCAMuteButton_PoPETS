import os
import sys
import argparse


parser = argparse.ArgumentParser()
parser.add_argument('--obj_path', help='This argument is meant to tell the script where a log generated by objdump is located.')

args = vars(parser.parse_args())

file_path = args["obj_path"]

t3 = '''

    void *which = (void *)drwrap_get_arg(wrapcxt, 0);


    char filename[128] = { 0 };
    dr_snprintf(filename, 128, "AES-Log.log");

    char buf[512];

    dr_snprintf(buf, 512, "Which: %ld\\n", which);
    
    filename[511] = '\\0';
    dr_mutex_lock(max_lock);
    FILE *fp = fopen(filename, "ab+");

    if (!fp) {
        dr_fprintf(STDERR, "Couldnâ€™t open the output file %s\\n", filename);
        return;
    }

    fwrite(buf, 1, sizeof(buf), fp);
    fclose(fp);
    dr_mutex_unlock(max_lock);
} '''

ignore_list = ["__ZNSt7", "mem", "memmove", "memset", "mutex", "pthread", "memcpy", "_ZNSt", "printf", "__ZTVN", "_ZN", "cos", "sin", "strcmp", "strcpy", "strlen", "g_", "strncmp", "bcmp", "strchr", "strspn", "clock_gettime", "u_foldCase_69", "_ZSt18_Rb_tree_incrementPSt18_Rb_tree_node_base", "log", "round", "u_charType_69", "errno", "ceilf", "_ZSt", "u_getIntPropertyValue_69", "uscript_getScript_69", "strdup", "floorf",  "strcspn", "strnlen", "getpid", "getenv", "exp2f", "__tls_get_addr", "tanhf" ,"strstr", "expf", "strncpy", "frexp", "truncf", "sched_yield", "__dynamic_cast", "u_hasBinaryProperty_69", "__ctype_b_loc", "_ZdlPv", "free", "calloc", "malloc", "realloc", "pread64", "isspace", "strtoul", "strtoul", "strtoull", "htonl", "ntohl", "htons", "__isoc99_sscanf", "abs", "exp", "strtoll", "strtol", "close", "open",  "str", "syscall", "wcrtomb", "bsearch", "powf", "mbrtowc", "dlsym", "write", "isdigit", "fgets", "readdir64", "_ZdaPv", "sqrt", "fflush", "floor", "recvmsg" ,"__cxa_atexit", "__cxa_guard_acquire", "ceil", "fcntl", "read", "__cxa_guard_release", "isprint", "ptrace", "ioctl"  ]

need_list = ["encrypt"]
def parse_file():
    
    if os.path.exists("top_file.txt"):
        os.remove("top_file.txt")
        os.remove("in_func.txt")
        os.remove("end_file.txt")


    with open(f"{file_path}", 'r') as f:
        for line in f:
            print(line)
            
            to_check = False
            for ele in ignore_list:
                if ele.upper() in line.strip().upper():
                    to_check = False
                    break
                elif ele.upper() == line.strip().upper():
                    to_check = False
                    break

            for ele in need_list:
                if ele.upper() in line.strip().upper() and "ssl".upper() not in line.strip().upper():
                    to_check = True
                    break
            
            if not to_check:
                continue   
            func_name = line.strip()
            template1 = f''' 
    towrap = (app_pc)dr_get_proc_address(mod->handle, "{func_name}");
    if (towrap != NULL) ~
        bool ok = drwrap_wrap(towrap, wrap_{func_name}, NULL);
        if (!ok) ~
            dr_fprintf(STDERR, "Couldn't get {func_name}\\n");
            
        `

    ` 
'''
            template1 = template1.replace("~", "{").replace("`", "}")
            template2 = f"static void wrap_{func_name}(void *wrapcxt,  void **user_data)"
            t6 = f'\n\n\tdr_mutex_lock(max_lock);\n\tprintf("IN {func_name}\\n");\n\tdr_mutex_unlock(max_lock);\n'
            template3 = template2 + "{" + t6 +t3
            
            with open("top_file.txt", "a") as f2:
                f2.write(template2+";\n")
            
            with open("in_func.txt", "a") as f2:
                f2.write(template1+"\n")

            with open("end_file.txt", "a") as f2:
                f2.write(template3+ "\n" )
            
if __name__ == "__main__":
    parse_file()